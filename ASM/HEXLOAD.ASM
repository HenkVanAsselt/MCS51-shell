 ;MicroControllerPascal compiler, vers. 3.11e copyright (C) KSC 1986, 1990
 ; With code generation for INTEL 8031
 ;
 ;{$M 0 0}
 ;
 ;
 ;VAR Mem                  : ARRAY[0..$FFFF] OF BYTE XDATA;
$DEBUG


	NAME	HEXLOAD

	USING	3
	USING	2
	USING	1
	USING	0

?HEXLOAD?X	SEGMENT	XDATA
 RSEG	?HEXLOAD?X
MEM:	DS	00H
 ;    Adr,FirstAdr,LastAdr : WORD DATA;
?HEXLOAD?D	SEGMENT	DATA
 RSEG	?HEXLOAD?D
ADR:	DS	02H
 RSEG	?HEXLOAD?D
FIRSTADR:	DS	02H
 RSEG	?HEXLOAD?D
LASTADR:	DS	02H
 ;     
 ;FUNCTION Byte2Hex(InByte: BYTE DATA):STRING[2] DATA;
 RSEG	?HEXLOAD?D
INBYTE:	DS	01H
 RSEG	?HEXLOAD?D
BYTE2HEX?RET:	DS	03H
 ;VAR Scratch : BYTE DATA;
 RSEG	?HEXLOAD?D
SCRATCH:	DS	01H
 ;BEGIN
?HEXLOAD?C	SEGMENT	CODE
	RSEG	?HEXLOAD?C

BYTE2HEX:
 ;  Scratch := Scratch AND $F0;
	MOV	A,SCRATCH
	ANL	A,#0F0H
	MOV	SCRATCH,A
 ;  Scratch := InByte SHR 4;
	MOV	A,#04H
	MOV	R6,A
	MOV	A,INBYTE
	CLR	C
	RRC	A
	DJNZ	R6,$-2
	MOV	SCRATCH,A
 ;  IF Scratch > $09 THEN Byte2Hex[1]:=CHR(Scratch+$37) 
	MOV	A,SCRATCH
	CLR	C
	SUBB	A,#09H
	JZ	$+3
	CPL	C
	JC	$+5
	LJMP	?L0
	MOV	A,SCRATCH
	ADD	A,#037H
 ;     ELSE Byte2Hex[1]:=CHR(Scratch+$30);
	MOV	BYTE2HEX?RET+01H,A
	LJMP	?L1
?L0:
	MOV	A,SCRATCH
	ADD	A,#030H
	MOV	BYTE2HEX?RET+01H,A
?L1:
 ;  Scratch := InByte AND $0F;
	MOV	A,INBYTE
	ANL	A,#0FH
	MOV	SCRATCH,A
 ;  IF Scratch > $09 THEN Byte2Hex[2]:=CHR(Scratch+$37) 
	MOV	A,SCRATCH
	CLR	C
	SUBB	A,#09H
	JZ	$+3
	CPL	C
	JC	$+5
	LJMP	?L2
	MOV	A,SCRATCH
	ADD	A,#037H
 ;     ELSE Byte2Hex[2]:=CHR(Scratch+$30);
	MOV	BYTE2HEX?RET+02H,A
	LJMP	?L3
?L2:
	MOV	A,SCRATCH
	ADD	A,#030H
	MOV	BYTE2HEX?RET+02H,A
?L3:
 ;  Byte2Hex[0]:=CHR(2)
 ;END{Byte2Hex};     
	MOV	BYTE2HEX?RET,#02H
	RET
 ;  
 ;
 ;PROCEDURE LoadHex;
 ;VAR Ch                      : CHAR DATA;
 RSEG	?HEXLOAD?D
CH:	DS	01H
 ;    Cs,Count,Number,EOFMark : BYTE DATA;
 RSEG	?HEXLOAD?D
CS:	DS	01H
 RSEG	?HEXLOAD?D
COUNT:	DS	01H
 RSEG	?HEXLOAD?D
NUMBER:	DS	01H
 RSEG	?HEXLOAD?D
EOFMARK:	DS	01H
 ;    FUNCTION Hex : BYTE DATA;
 RSEG	?HEXLOAD?D
HEX?RET:	DS	01H
 ;    VAR Bb : BYTE DATA;
 RSEG	?HEXLOAD?D
BB:	DS	01H
 ;        FUNCTION Nibble : BYTE DATA;
 RSEG	?HEXLOAD?D
NIBBLE?RET:	DS	01H
 ;        BEGIN
	RSEG	?HEXLOAD?C

NIBBLE:
 ;          Read(Ch);
	MOV	R3,#00H
	LCALL	?READ1C
	MOV	CH,R2
 ;          IF Ch > '9' THEN Nibble := ORD(Ch)-$37
	MOV	A,CH
	CLR	C
	SUBB	A,#039H
	JZ	$+3
	CPL	C
	JC	$+5
	LJMP	?L4
 ;          ELSE Nibble := ORD(Ch)-$30;
	MOV	A,CH
	CLR	C
	SUBB	A,#037H
	MOV	NIBBLE?RET,A
	LJMP	?L5
?L4:
	MOV	A,CH
	CLR	C
	SUBB	A,#030H
	MOV	NIBBLE?RET,A
?L5:
 ;        END{Nibble};
	RET
 ;    BEGIN{Hex}
	RSEG	?HEXLOAD?C

HEX:
 ;      Bb := Nibble SHL 4 + Nibble;
	LCALL	NIBBLE
	MOV	A,#04H
	MOV	R6,A
	MOV	A,NIBBLE?RET
	CLR	C
	RLC	A
	DJNZ	R6,$-2
	MOV	R6,A
	PUSH	06H
	LCALL	NIBBLE
	POP	06H
	MOV	A,R6
	ADD	A,NIBBLE?RET
	MOV	BB,A
 ;      Cs := Cs + Bb;
	MOV	A,CS
	ADD	A,BB
	MOV	CS,A
 ;      Hex := Bb;
	MOV	HEX?RET,BB
 ;    END{Hex};
	RET
 ;    BEGIN{LoadHex}
	RSEG	?HEXLOAD?C

LOADHEX:
 ;      FirstAdr := $4000;
	MOV	FIRSTADR,#LOW(04000H)
	MOV	FIRSTADR+01H,#HIGH(04000H)
 ;      LastAdr := 0;
	MOV	LASTADR,#LOW(00H)
	MOV	LASTADR+01H,#HIGH(00H)
 ;      Read(Ch);
	MOV	R3,#00H
	LCALL	?READ1C
	MOV	CH,R2
 ;      REPEAT
?L6:
 ;        WHILE (Ch <> ':') AND (Ch <> #27) DO Read(Ch);
?L7:
	MOV	A,CH
	CLR	C
	SUBB	A,#03AH
	JZ	$+4
	MOV	A,#01H
	MOV	R6,A
	MOV	A,CH
	CLR	C
	SUBB	A,#01BH
	JZ	$+4
	MOV	A,#01H
	RRC	A
	MOV	A,R6
	ANL	C,ACC
	JC	$+5
	LJMP	?L8
	MOV	R3,#00H
	LCALL	?READ1C
	MOV	CH,R2
	SJMP	?L7
?L8:
 ;        IF Ch = ':' THEN 
	MOV	A,CH
	CLR	C
	SUBB	A,#03AH
	JZ	$+5
	LJMP	?L9
 ;        BEGIN
 ;          Cs := 0;
	MOV	CS,#00H
 ;          Number := Hex;
	LCALL	HEX
	MOV	NUMBER,HEX?RET
 ;          Adr := (Hex * 256) + Hex;
	LCALL	HEX
	MOV	R4,#LOW(0100H)
	MOV	R5,#HIGH(0100H)
	MOV	R2,HEX?RET
	MOV	R3,#00H
	LCALL	?IMUL
	PUSH	02H
	PUSH	03H
	LCALL	HEX
	POP	03H
	POP	02H
	MOV	A,R2
	ADD	A,HEX?RET
	MOV	R2,A
	MOV	A,R3
	ADDC	A,#00H
	MOV	R3,A
	MOV	ADR,R2
	MOV	ADR+01H,R3
 ;          IF Adr < FirstAdr THEN FirstAdr := Adr;
	MOV	A,ADR+01H
	CJNE	A,FIRSTADR+01H,$+08H
	MOV	A,ADR
	CJNE	A,FIRSTADR,$+03H
	JC	$+5
	LJMP	?L10
	MOV	FIRSTADR,ADR
	MOV	FIRSTADR+01H,ADR+01H
?L10:
 ;          EOFMark := Hex;  
	LCALL	HEX
	MOV	EOFMARK,HEX?RET
 ;          IF Number > 0 THEN
	MOV	A,NUMBER
	CLR	C
	SUBB	A,#00H
	JZ	$+3
	CPL	C
	JC	$+5
	LJMP	?L11
 ;             BEGIN
 ;               FOR Count := 1 TO Number DO
	MOV	COUNT,#01H
?L12:
 ;                   BEGIN
	MOV	A,COUNT
	CLR	C
	SUBB	A,NUMBER
	JZ	$+3
	CPL	C
	JNC	$+5
	LJMP	?L13
 ;                     Mem[Adr] := Hex;
	MOV	DPTR,#MEM
	MOV	A,ADR
	ADD	A,DPL
	MOV	DPL,A
	MOV	A,DPH
	ADDC	A,ADR+01H
	MOV	DPH,A
	PUSH	DPL
	PUSH	DPH
	LCALL	HEX
	POP	DPH
	POP	DPL
	MOV	A,HEX?RET
	MOVX	@DPTR,A
 ;                     Inc(Adr);
	INC	ADR
	MOV	A,#00H
	CJNE	A,ADR,$+5
	INC	ADR+01H
 ;               END{FOR};
	INC	COUNT
	MOV	A,COUNT
	JZ	$+5
	SJMP	?L12
	NOP
?L13:
 ;             END{IF};
?L11:
 ;           END{IF};
?L9:
 ;           IF Adr > LastAdr THEN LastAdr := Adr;
	MOV	A,ADR+01H
	CJNE	A,LASTADR+01H,$+09H
	MOV	A,ADR
	CJNE	A,LASTADR,$+04H
	CPL	C
	JNC	$+5
	LJMP	?L14
	MOV	LASTADR,ADR
	MOV	LASTADR+01H,ADR+01H
?L14:
 ;      UNTIL (Number = 0) OR (Ch = #27) OR (EOFMark = 1);
	MOV	A,NUMBER
	CLR	C
	SUBB	A,#00H
	JZ	$+4
	MOV	A,#01H
	CPL	A
	MOV	R6,A
	MOV	A,CH
	CLR	C
	SUBB	A,#01BH
	JZ	$+4
	MOV	A,#01H
	CPL	A
	RRC	A
	MOV	A,R6
	ORL	C,ACC
	MOV	A,#00H
	RLC	A
	MOV	R6,A
	MOV	A,EOFMARK
	CLR	C
	SUBB	A,#01H
	JZ	$+4
	MOV	A,#01H
	CPL	A
	RRC	A
	MOV	A,R6
	ORL	C,ACC
	JC	$+5
	LJMP	?L6
 ;END{LoadHex};
	RET
 ;
 ;BEGIN

	RSEG	?HEXLOAD?C

BEGIN:
 ;  Reset(serial);
	MOV	R3,#00H
	LCALL	?RESET
 ;  WriteLn('8051 Simulator program',#10,#13);
	SJMP	$+25
?S449:
	DB	016H
?S450:
	DB	038H
	DB	030H
	DB	035H
	DB	031H
	DB	020H
	DB	053H
	DB	069H
	DB	06DH
	DB	075H
	DB	06CH
	DB	061H
	DB	074H
	DB	06FH
	DB	072H
	DB	020H
	DB	070H
	DB	072H
	DB	06FH
	DB	067H
	DB	072H
	DB	061H
	DB	06DH
	MOV	DPTR,#?S450
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	R7,#016H
	MOV	R6,#00H
	LCALL	?WRITS
	MOV	A,#0AH
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	MOV	A,#0DH
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	MOV	R3,#00H
	LCALL	?CRLF
 ;  WriteLn('Download HEX-FILE now ...');
	SJMP	$+28
?S521:
	DB	019H
?S522:
	DB	044H
	DB	06FH
	DB	077H
	DB	06EH
	DB	06CH
	DB	06FH
	DB	061H
	DB	064H
	DB	020H
	DB	048H
	DB	045H
	DB	058H
	DB	02DH
	DB	046H
	DB	049H
	DB	04CH
	DB	045H
	DB	020H
	DB	06EH
	DB	06FH
	DB	077H
	DB	020H
	DB	02EH
	DB	02EH
	DB	02EH
	MOV	DPTR,#?S522
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	R7,#019H
	MOV	R6,#00H
	LCALL	?WRITS
	MOV	R3,#00H
	LCALL	?CRLF
 ;
 ;  LoadHex;
	LCALL	LOADHEX
 ;
 ;  WriteLn(#10,#13,'Loading complete',#10,#13);
	MOV	A,#0AH
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	MOV	A,#0DH
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	SJMP	$+19
?S599:
	DB	010H
?S600:
	DB	04CH
	DB	06FH
	DB	061H
	DB	064H
	DB	069H
	DB	06EH
	DB	067H
	DB	020H
	DB	063H
	DB	06FH
	DB	06DH
	DB	070H
	DB	06CH
	DB	065H
	DB	074H
	DB	065H
	MOV	DPTR,#?S600
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	R7,#010H
	MOV	R6,#00H
	LCALL	?WRITS
	MOV	A,#0AH
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	MOV	A,#0DH
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	MOV	R3,#00H
	LCALL	?CRLF
 ;  WriteLn('First Address ',Byte2Hex(FirstAdr SHR 8),Byte2Hex(FirstAdr AND $00FF),'h');
	SJMP	$+17
?S665:
	DB	0EH
?S666:
	DB	046H
	DB	069H
	DB	072H
	DB	073H
	DB	074H
	DB	020H
	DB	041H
	DB	064H
	DB	064H
	DB	072H
	DB	065H
	DB	073H
	DB	073H
	DB	020H
	MOV	DPTR,#?S666
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	R7,#0EH
	MOV	R6,#00H
	LCALL	?WRITS
	MOV	R4,#LOW(08H)
	MOV	R5,#HIGH(08H)
	MOV	R2,FIRSTADR
	MOV	R3,FIRSTADR+01H
	LCALL	?ISHR
	MOV	A,R2
	MOV	INBYTE,A
	LCALL	BYTE2HEX
	MOV	R0,#BYTE2HEX?RET
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	A,@R0
	INC	R0
	MOV	R7,A
	MOV	R6,#01H
	LCALL	?WRITS
	MOV	A,FIRSTADR
	ANL	A,#LOW(0FFH)
	MOV	R2,A
	MOV	A,FIRSTADR+01H
	ANL	A,#00H
	MOV	R3,A
	MOV	A,R2
	MOV	INBYTE,A
	LCALL	BYTE2HEX
	MOV	R0,#BYTE2HEX?RET
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	A,@R0
	INC	R0
	MOV	R7,A
	MOV	R6,#01H
	LCALL	?WRITS
	MOV	A,#068H
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	MOV	R3,#00H
	LCALL	?CRLF
 ;  WriteLn('Last Address  ',Byte2Hex(LastAdr SHR 8),Byte2Hex(LastAdr AND $00FF),'h');
	SJMP	$+17
?S776:
	DB	0EH
?S777:
	DB	04CH
	DB	061H
	DB	073H
	DB	074H
	DB	020H
	DB	041H
	DB	064H
	DB	064H
	DB	072H
	DB	065H
	DB	073H
	DB	073H
	DB	020H
	DB	020H
	MOV	DPTR,#?S777
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	R7,#0EH
	MOV	R6,#00H
	LCALL	?WRITS
	MOV	R4,#LOW(08H)
	MOV	R5,#HIGH(08H)
	MOV	R2,LASTADR
	MOV	R3,LASTADR+01H
	LCALL	?ISHR
	MOV	A,R2
	MOV	INBYTE,A
	LCALL	BYTE2HEX
	MOV	R0,#BYTE2HEX?RET
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	A,@R0
	INC	R0
	MOV	R7,A
	MOV	R6,#01H
	LCALL	?WRITS
	MOV	A,LASTADR
	ANL	A,#LOW(0FFH)
	MOV	R2,A
	MOV	A,LASTADR+01H
	ANL	A,#00H
	MOV	R3,A
	MOV	A,R2
	MOV	INBYTE,A
	LCALL	BYTE2HEX
	MOV	R0,#BYTE2HEX?RET
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	A,@R0
	INC	R0
	MOV	R7,A
	MOV	R6,#01H
	LCALL	?WRITS
	MOV	A,#068H
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	MOV	R3,#00H
	LCALL	?CRLF
 ;  WriteLn(#10,#13,'Now tumble the switch ...');
	MOV	A,#0AH
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	MOV	A,#0DH
	MOV	R2,A
	MOV	R4,#01H
	MOV	R5,#00H
	MOV	R6,#04H
	MOV	R7,#01H
	LCALL	?WRITS
	SJMP	$+28
?S915:
	DB	019H
?S916:
	DB	04EH
	DB	06FH
	DB	077H
	DB	020H
	DB	074H
	DB	075H
	DB	06DH
	DB	062H
	DB	06CH
	DB	065H
	DB	020H
	DB	074H
	DB	068H
	DB	065H
	DB	020H
	DB	073H
	DB	077H
	DB	069H
	DB	074H
	DB	063H
	DB	068H
	DB	020H
	DB	02EH
	DB	02EH
	DB	02EH
	MOV	DPTR,#?S916
	MOV	R5,#00H
	MOV	R4,#01H
	MOV	R7,#019H
	MOV	R6,#00H
	LCALL	?WRITS
	MOV	R3,#00H
	LCALL	?CRLF
 ;
 ;
 ;  REPEAT UNTIL FALSE;
?L15:
	SJMP	?L15
 ;END{Main}.
?L16:
	SJMP	?L16

CSEG

	ORG	00H
	SJMP	$+26H
	ORG	026H
	LCALL	?INITSTACK
	LCALL	?INITHEAP
	LJMP	BEGIN
 EXTRN	CODE ( ?IMUL )
 EXTRN	CODE ( ?WRITS )
 EXTRN	CODE ( ?CRLF )
 EXTRN	CODE ( ?READ1C )
 EXTRN	CODE ( ?INITSTACK )
 EXTRN	CODE ( ?INITHEAP )
 EXTRN	CODE ( ?ISHR )
 EXTRN	CODE ( ?RESET )

	BSEG
	DBIT	8


END
