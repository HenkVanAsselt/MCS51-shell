; Runtime package for system51, Copyright (c) 1986 KSC Software Systems.

; latest revision 900904 for system51 revision  3.10b


LIBRARY	STRINT
PUBLIC ?STRINT

; string handling routines for the SYSTEM51
; 870712 KSC Software Systems
; There are 2 routines for STR(i,s)  (for integers)

EXTRN	CODE	( ?WRITI, ?WRITW )
EXTRN	DATA	( ?AR0, ?AR4 )

?STRINT?C	SEGMENT	CODE

	RSEG	?STRINT?C

?STRINT:
	MOV	B,A		; Integer or word
	MOV	A,R0
	PUSH	ACC
	MOV	R6,#5		; Device number
	MOV	?AR4,#0		; Dynamic length of string
	INC	R0
	MOV	?AR0,R0
	MOV	A,B
	JNZ	$+7
	CALL	?WRITI
	SJMP	$+5
	CALL	?WRITW
	POP	ACC
	MOV	R1,A
	MOV	@R1,?AR4		; set dynamic length
	RET


LIBEND

LIBRARY	STREXT
PUBLIC ?STREXT
EXTRN	CODE ( ?WRITI, ?WRITW )
EXTRN	DATA	( ?AR4 )

?STREXT?C	SEGMENT	CODE

	RSEG	?STREXT?C

; When called: DPTR contains address of start of string
; IACC (R2,R3) contains number to convert

?STREXT:
	PUSH	DPL
	PUSH	DPH
	INC	DPTR
	MOV	R6,#6		; Device number
	MOV	?AR4,#0		; Dynamic length of string starts with 0
	JZ	STXI
	CALL	?WRITW
	SJMP	STXW
STXI:	CALL	?WRITI
STXW:	MOV	A,?AR4
	POP	DPH
	POP	DPL
	MOVX	@DPTR,A		; set actual string length
	RET

LIBEND

$EJECT

; Routines CONCATI for string addition; at entry A contains concat-
; type no: n=0, string in RAM, n=1, string in EXT, n=2, string in CODE
; 1. operand and result always in floating-point scrollstack, ie. from
; ?FLOATBUFFER TO ?FLOATBUFFER+10H
; this routine is used when no external memory is declared.

LIBRARY	CONCATI
PUBLIC	?CONCATI
PUBLIC	?ICONCATI

EXTRN	DATA	( ?FLOATBUFFER )

?CONCATI?C	SEGMENT	CODE

	RSEG	?CONCATI?C


?CONCATI:
	JZ	CONC0
	DEC	A
	JZ	CONC1
CONC2:  ; 2. string in CODE, pointer is DPTR
	MOV	A,#0
	MOVC	A,@A+DPTR	;number of chars in 2. string
	MOV	R4,A
	MOV	R5,?FLOATBUFFER		; and in 1.
	ADD	A,R5
	MOV	R5,A
	CLR	C
	MOV	A,#16
	SUBB	A,R5		; max 16 in string
	JNC	CONC2A
	MOV	R6,A
	ADD	A,R4
	MOV	R4,A
	MOV	A,R6
	ADD	A,R5
	MOV	R5,A

CONC2A:	INC	R4
	MOV	R0,#?FLOATBUFFER+1
	MOV	A,?FLOATBUFFER
	ADD	A,R0
	MOV	R0,A
CONC2C:	DEC	R4
	MOV	A,R4
	JZ	CONC2B
	INC	DPTR
	MOV	A,#0
	MOVC	A,@A+DPTR
	MOV	@R0,A
	INC	R0
	SJMP	CONC2C
CONC2B:	MOV	?FLOATBUFFER,R5
	MOV	R0,#?FLOATBUFFER
	RET

CONC1:  ; 2. string in EXT, pointer is DPTR
	MOVX	A,@DPTR		;number of chars in 2. string
	MOV	R4,A
	MOV	R5,?FLOATBUFFER		; and in 1.
	ADD	A,R5
	MOV	R5,A
	CLR	C
	MOV	A,#16
	SUBB	A,R5		; max 16 in string
	JNC	CONC1C
	
	MOV	R6,A
	ADD	A,R4
	MOV	R4,A
	MOV	A,R6
	ADD	A,R5
	MOV	R5,A

CONC1C:	INC	R4
	MOV	R0,#?FLOATBUFFER+1
	MOV	A,?FLOATBUFFER
	ADD	A,R0
	MOV	R0,A
CONC1A:	DEC	R4
	MOV	A,R4
	JZ	CONC1B
	INC	DPTR
	MOV	A,#0
	MOVX	A,@DPTR
	MOV	@R0,A
	INC	R0
	SJMP	CONC1A
CONC1B:	MOV	?FLOATBUFFER,R5
	MOV	R0,#?FLOATBUFFER
	RET

CONC0:	MOV	A,@R0		;number of chars in 2. string
	MOV	R4,A
	MOV	R5,?FLOATBUFFER	; and in 1.
	ADD	A,R5
	MOV	R5,A
	
	CLR	C
	MOV	A,#16
	SUBB	A,R5		; max 16 in string
	JNC	CONC0A
	MOV	R6,A
	ADD	A,R4
	MOV	R4,A
	MOV	A,R6
	ADD	A,R5
	MOV	R3,A

CONC0A:	INC	R4
	MOV	R1,#?FLOATBUFFER+1
	MOV	A,?FLOATBUFFER
	ADD	A,R1
	MOV	R1,A
CONC0C:	DEC	R4
	MOV	A,R4
	JZ	CONC0B
	INC	R0
	MOV	A,@R0
	MOV	@R1,A
	INC	R1
	SJMP	CONC0C
CONC0B:	MOV	?FLOATBUFFER,R5
	MOV	R0,#?FLOATBUFFER
	RET


?ICONCATI:
	MOV	?FLOATBUFFER,#0
	RET

LIBEND

LIBRARY	CONCATX
PUBLIC ?CONCATX,?STRBUF,?ICONCATX
EXTRN	DATA	( ?USERDPL,?USERDPH,?SYSDPL,?SYSDPH,?USERCOUNT,?SYSCOUNT )
?CONCATX?C	SEGMENT	CODE
?CONCATX?X	SEGMENT	XDATA
RSEG	?CONCATX?X

?STRBUF:
	DS	81

RSEG	?CONCATX?C


CONC0:	JMP	ACONC0

?CONCATX:
	JZ	CONC0
	DEC	A
	JZ	CONC1
CONC2:  ; 2. string in CODE, pointer to code is in DPTR
	MOV	A,#0
	MOVC	A,@A+DPTR
	JZ	CONC2B
	MOV	?USERCOUNT,A

CONC2A:	INC	DPTR
	MOV	A,#0
	MOVC	A,@A+DPTR
	MOV	?USERDPL,DPL
	MOV	?USERDPH,DPH

	INC	?SYSCOUNT
	MOV	DPL,?SYSDPL
	MOV	DPH,?SYSDPH
	MOVX	@DPTR,A
	INC	DPTR
	MOV	?SYSDPL,DPL
	MOV	?SYSDPH,DPH
	MOV	DPL,?USERDPL
	MOV	DPH,?USERDPH
	DJNZ	?USERCOUNT,CONC2A

CONC2B:	MOV	DPTR,#?STRBUF
	MOV	A,?SYSCOUNT
	MOVX	@DPTR,A
	RET

CONC1:  ; 2. string in EXT, pointer to XDATA is in DPTR
	MOVX	A,@DPTR
	JZ	CONC1B
	MOV	?USERCOUNT,A

CONC1A:	
	INC	DPTR
	MOVX	A,@DPTR
	MOV	?USERDPL,DPL
	MOV	?USERDPH,DPH
	INC	?SYSCOUNT

	MOV	DPL,?SYSDPL
	MOV	DPH,?SYSDPH
	MOVX	@DPTR,A
	INC	DPTR
	MOV	?SYSDPL,DPL
	MOV	?SYSDPH,DPH
	MOV	DPL,?USERDPL
	MOV	DPH,?USERDPH
	DJNZ	?USERCOUNT,CONC1A
	
CONC1B:	MOV	DPTR,#?STRBUF
	MOV	A,?SYSCOUNT
	MOVX	@DPTR,A
	RET

ACONC0:	MOV	A,@R0
	JZ	CONC0B
	MOV	?USERCOUNT,A
	
	MOV	DPL,?SYSDPL
	MOV	DPH,?SYSDPH

CONC0A:	INC	?SYSCOUNT
	INC	R0
	MOV	A,@R0
	MOVX	@DPTR,A
	INC	DPTR
	DJNZ	?USERCOUNT,CONC0A
	
CONC0B:	MOV	?SYSDPL,DPL
	MOV	?SYSDPH,DPH
	MOV	DPTR,#?STRBUF
	MOV	A,?SYSCOUNT
	MOVX	@DPTR,A
	RET


?ICONCATX:
	MOV	?USERDPL,DPL
	MOV	?USERDPH,DPH
 	MOV	DPTR,#?STRBUF
 	MOV	A,#0
 	MOVX	@DPTR,A
 	MOV	?SYSCOUNT,A
 	INC	DPTR
 	MOV	?SYSDPL,DPL
 	MOV	?SYSDPH,DPH
 	MOV	DPL,?USERDPL
 	MOV	DPH,?USERDPH
 	RET
 	
	

LIBEND



$EJECT
LIBRARY	READD
; Two routines for read string are supported: 
;READD for internal and READDX for external memory.

; at call: ?DEVICE contains device driver number, R0 or DPTR pointer to read area.

PUBLIC	?READD
?READD?C	SEGMENT	CODE
RSEG	?READD?C
EXTRN	CODE	( ?READC )
EXTRN	DATA	( ?DEVICE )

?READD:	MOV	A,R0
	MOV	R1,A
	MOV	R7,#0
	MOV	?DEVICE,R3

READD1:
	CALL	?READC
	MOV	A,R2
	CLR	C
	SUBB	A,#0DH	; cr
	JZ	READD2
	INC	R0
	INC	R7
	MOV	A,R2
	MOV	@R0,A
	DJNZ	R4,READD1
	
READD2:	MOV	A,R7
	MOV	@R1,A
	RET

LIBEND
                    
LIBRARY	READDX

PUBLIC ?READDX
EXTRN CODE ( ?READC )
EXTRN	DATA	( ?DEVICE )
?READDX?C	SEGMENT	CODE
RSEG	?READDX?C

?READDX:
	MOV	R5,DPL
	MOV	R6,DPH
	MOV	R7,#0
	MOV	?DEVICE,R3
READDX1:
	CALL	?READC
	MOV	A,R2
	CLR	C
	SUBB	A,#0DH	; cr
	JZ	READDX2
	INC	DPTR
	INC	R7
	MOV	A,R2
	MOVX	@DPTR,A
	DJNZ	R4,READDX1
	
READDX2:
	MOV	DPL,R5
	MOV	DPH,R6
	MOV	A,R7
	MOVX	@DPTR,A
	RET

LIBEND

;This module will convert a string to integer.
; 870729 KSC
;At entry R6 and probably R0 or DPTR will contain parameters for READC
;At termination, result will be in IACC (R2,R3)

LIBRARY	VALINT
PUBLIC ?VALINT ; Both string and results in Internal RAM
PUBLIC ?VALEXT ; Both string and results in External RAM
EXTRN CODE (?READI, ?GETHJ)
EXTRN	DATA	( ?AR0, ?AR4, ?HJ )
?VALINT?C	SEGMENT	CODE
RSEG	?VALINT?C

;
?VALINT:
	MOV	A,R4	
	PUSH	ACC	;var-parameter address
	MOV	R3,#5	;channel no.
	MOV	A,@R0	;no. of chars
	INC	R0
	MOV	?AR0,R0
	INC	A
	MOV	?AR4,A
	MOV	?HJ,A
	CALL	?READI
	POP	ACC
	MOV	R0,A
	MOV	A,R2	;v:=v1
	MOV	@R0,A
	INC	R0
	MOV	A,R3
	MOV	@R0,A
	CALL	?GETHJ
	RET
	
?VALEXT:
	PUSH	DPL	;var-parameter addresses
	PUSH	DPH
	MOV	DPL,R4
	MOV	DPH,R5
	MOV	R3,#6	
	MOVX	A,@DPTR	;number of char in string
	INC	DPTR
	INC	A
	MOV	?AR4,A
	MOV	?HJ,A
	CALL	?READI
	POP	DPH
	POP	DPL
	MOV	A,R2	;v:=v1
	MOVX	@DPTR,A
	INC	DPTR
	MOV	A,R3
	MOVX	@DPTR,A
	CALL	?GETHJ
	RET

	
LIBEND

LIBRARY HJ

PUBLIC ?GETHJ, ?HJ

EXTRN	DATA	( ?AR4 )

HJ?D	SEGMENT	DATA
RSEG HJ?D

?HJ:	DS	1

HJ?C	SEGMENT	CODE
RSEG	HJ?C

?GETHJ:	CLR	C
	MOV	A,?HJ
	SUBB	A,?AR4
	MOV	R4,A
	RET

LIBEND


 ;MicroControllerPascal compiler, vers. 3.0alfa copyright (C) KSC 1986, 1988
 ; With code generation for INTEL 8051
 ;
 ;procedure readi(var v1: integer);


LIBRARY	READI3

	USING	0

?READI3?D	SEGMENT	DATA
 RSEG	?READI3?D
V1:	DS	02H
 ;var
 ; ii: integer;
 ; ?device: byte import;
 RSEG	?READI3?D
II:	DS	02H
EXTRN	DATA	( ?DEVICE )
 ; ch: char;
 RSEG	?READI3?D
CH:	DS	01H
 ; minus: boolean at 0;
MINUS	EQU	00H
 ;begin
?READI3?C	SEGMENT	CODE
	RSEG	?READI3?C

PUBLIC	?READI

?READI:
	MOV	?DEVICE,R3
 ; ii:=0;
	MOV	II,#LOW(00H)
	MOV	II+01H,#HIGH(00H)
 ; read(ch);
	LCALL	?READC
	MOV	CH,R2
 ; minus:=false;
	CLR	MINUS
 ; if ch='-' then
	MOV	A,CH
	CLR	C
	SUBB	A,#02DH
	JZ	$+5
	LJMP	?L0
 ; begin
 ;  minus:=true;
	SETB	MINUS
 ;  read(ch);
	LCALL	?READC
	MOV	CH,R2
 ; end;
?L0:
 ; while (ch>='0') and (ch<='9') do
?L1:
	MOV	A,CH
	CLR	C
	SUBB	A,#030H
	CPL	C
	RLC	A
	MOV	R2,A
	MOV	A,CH
	CLR	C
	SUBB	A,#039H
	JZ	$+3
	CPL	C
	CPL	C
	MOV	A,R2
	ANL	C,ACC
	JC	$+5
	LJMP	?L2
 ; begin
 ;  ii:=ii*10+ord(ch)-48;
	MOV	R4,#LOW(0AH)
	MOV	R5,#HIGH(0AH)
	MOV	R2,II
	MOV	R3,II+01H
	LCALL	?IMUL
	MOV	A,CH
	MOV	R4,A
	MOV	R5,#00H
	LCALL	?IADD
	MOV	A,R2
	CLR	C
	SUBB	A,#LOW(030H)
	MOV	R2,A
	MOV	A,R3
	SUBB	A,#HIGH(030H)
	MOV	R3,A
	MOV	II,R2
	MOV	II+01H,R3
 ;  read(ch);
	LCALL	?READC
	MOV	CH,R2
 ; end;
	SJMP	?L1
?L2:
 ; if minus then ii:=-ii;
	JB	MINUS,$+6
	LJMP	?L3
	MOV	R2,II
	MOV	R3,II+01H
	LCALL	?INEG
	MOV	II,R2
	MOV	II+01H,R3
?L3:
 ; v1:=ii; (* returv‘rdi i R2,R3 *)
	MOV	R2,II
	MOV	R3,II+01H
 ;end;
	RET
 ;
 ;begin

	RSEG	?READI3?C

 ;end.
 EXTRN	CODE ( ?IADD )
 EXTRN	CODE ( ?INEG )
 EXTRN	CODE ( ?IMUL )
 EXTRN	CODE ( ?READC )
LIBEND

LIBRARY READ1C

PUBLIC	?READ1C

EXTRN	CODE	(?READC)
EXTRN	DATA	(?DEVICE)

?READ1C?C	SEGMENT	CODE

RSEG	?READ1C?C

?READ1C:
	MOV	?DEVICE,R3
	JMP	?READC

LIBEND

LIBRARY	SIGNEXTB

; A 8 bit number in Acc will be sign extended to R3, Acc. R3 must contain 0
PUBLIC ?SIGNEXTB
?SIGNEXTB?C	SEGMENT	CODE
RSEG	?SIGNEXTB?C

?SIGNEXTB:
	JNB	0E7H,LABEL1
	DEC	R3

LABEL1:	RET

LIBEND

  LIBRARY	WRITS
  PUBLIC ?WRITS
  EXTRN  CODE	( ?WRITC )
  EXTRN	DATA	( ?DEVICE )
  ?WRITS?C	SEGMENT	CODE
  RSEG	?WRITS?C

;procedure WRITS will write a string to device numbered in R5
;R6 will contain type of memory from which to pick the string.
;R5 will contain the dynamic string length.
;R4 will contain the string length format.

?WRITS:
	MOV	?DEVICE,R5
	MOV	A,R4
	CLR	C
	SUBB	A,R7
	JC	WRS1
	JZ	WRS1
	MOV	R4,A
	MOV	A,R2
	MOV	R5,A
WRS2:	MOV	R2,#' '		; Write format blanks
	CALL	?WRITC
	DJNZ	R4,WRS2	
	MOV	A,R5
	MOV	R2,A
WRS1:	MOV	A,R7
	JZ	WRITSRET
	MOV	A,R6
	JZ	WRITS0
	DEC	A
	JZ	WRITS1
	DEC	A
	JZ	WRITS2
	DEC	A
	JZ	WRITS3

; 1 char in R2
WRITS4: CALL	?WRITC
WRITSRET:
	RET

; string of 2 bytes in integer accumulator
WRITS3:
	MOV	A,R2
	MOV	R2,A
	LCALL	?WRITC
	MOV	A,R3
	MOV	R2,A
	LCALL	?WRITC
	RET

; string in internal data memory.
WRITS1:	MOV	A,@R0
	MOV	R2,A
	LCALL	?WRITC
	INC	R0
	DJNZ	R7,WRITS1
	RET

; string in external memory
WRITS2:
	MOVX	A,@DPTR
	INC	DPTR
	MOV	R2,A
	LCALL	?WRITC
	DJNZ	R7,WRITS2
	RET

; string in CODE memory
WRITS0:	MOV	A,#0
	MOVC	A,@A+DPTR
	INC	DPTR
	MOV	R2,A
	LCALL	?WRITC
	DJNZ	R7,WRITS0
	RET

LIBEND


LIBRARY	WRITI3

	USING	0

 ; ?talarray: array[0..4] of char import;
 EXTRN DATA(?TALARRAY)
 ; ?sign: boolean import;
	EXTRN BIT(?SIGN)
 ; ?i,?colonm,?device: byte import;
 ; i: byte;
 EXTRN DATA(?I)
 EXTRN DATA(?COLONM)
 EXTRN DATA(?DEVICE)
 ; {$A PUBLIC  ?WRITW}

 PUBLIC  ?WRITW
 ;procedure register export ?writi(ii: integer);
?WRITI3?D	SEGMENT	DATA
 RSEG	?WRITI3?D
II:	DS	02H
I:	DS	01H
 ;begin
 PUBLIC ?WRITI
?WRITI3?C	SEGMENT	CODE
	RSEG	?WRITI3?C

?WRITW:
	MOV	?DEVICE,R6
	MOV	?COLONM,R7
	MOV	II,R2
	MOV	II+1,R3
	SJMP	?L0

?WRITI:
	MOV	?DEVICE,R6
	MOV	?COLONM,R7
	MOV	II,R2
	MOV	II+01H,R3
 ; if ii<0 then
	MOV	R4,#LOW(00H)
	MOV	R5,#HIGH(00H)
	LCALL	?ICOMP
	JC	$+5
	LJMP	?L0
 ; begin
 ;  ?sign:=true;
	SETB	?SIGN
 ;  if ?colonm>0 then dec(?colonm);
	MOV	A,?COLONM
	CLR	C
	SUBB	A,#00H
	JZ	$+3
	CPL	C
	JC	$+5
	LJMP	?L1
	DEC	?COLONM
?L1:
 ;  ii:=-ii;
	MOV	R2,II
	MOV	R3,II+01H
	LCALL	?INEG
	MOV	II,R2
	MOV	II+01H,R3
 ; end
 ; else
	LJMP	?L2
?L0:
 ;  ?sign:=false;;
	CLR	?SIGN
?L2:
 ; ?i:=4;
	MOV	?I,#04H
 ; repeat
?L3:
 ;  ?talarray[?i]:=chr(ii mod 10 + 48);
	MOV	A,?I
	ADD	A,#?TALARRAY
	MOV	R0,A
	MOV	R4,#LOW(0AH)
	MOV	R5,#HIGH(0AH)
	MOV	R2,II
	MOV	R3,II+01H
	LCALL	?WMOD
	MOV	A,R2
	ADD	A,#LOW(030H)
	MOV	R2,A
	MOV	A,R3
	ADDC	A,#HIGH(030H)
	MOV	R3,A
	MOV	A,R2
	MOV	@R0,A
 ;  ii:=ii div 10;
	MOV	R4,#LOW(0AH)
	MOV	R5,#HIGH(0AH)
	MOV	R2,II
	MOV	R3,II+01H
	LCALL	?WDIV
	MOV	II,R2
	MOV	II+01H,R3
 ;  if ?colonm>0 then dec(?colonm);
	MOV	A,?COLONM
	CLR	C
	SUBB	A,#00H
	JZ	$+3
	CPL	C
	JC	$+5
	LJMP	?L4
	DEC	?COLONM
?L4:
 ;  dec(?i);
	DEC	?I
 ; until ii=0;
	MOV	R4,#LOW(00H)
	MOV	R5,#HIGH(00H)
	MOV	R2,II
	MOV	R3,II+01H
	LCALL	?WCOMP
	JNZ	?L3
 ; for i:=1 to ?colonm do write(' ');
	MOV	I,#01H
?L6:
	MOV	A,?COLONM
	CLR	C
	SUBB	A,I
	JNC	$+5
	LJMP	?L7
	PUSH	02H
	PUSH	03H
	MOV	A,#020H
	MOV	R2,A
	LCALL	?WRITC
	POP	03H
	POP	02H
	INC	I
	MOV	A,I
	JZ	$+5
	SJMP	?L6
	NOP
?L7:
 ; if ?sign then write('-');
	JB	?SIGN,$+6
	LJMP	?L5
	PUSH	02H
	PUSH	03H
	MOV	A,#02DH
	MOV	R2,A
	LCALL	?WRITC
	POP	03H
	POP	02H
?L5:
 ; for ?i:=?i+1 to 4 do
	MOV	A,?I
	ADD	A,#01H
	MOV	?I,A
?L8:
 ;  write(?talarray[?i]);
	MOV	A,#04H
	CLR	C
	SUBB	A,?I
	JNC	$+5
	LJMP	?L9
	PUSH	02H
	PUSH	03H
	MOV	A,?I
	ADD	A,#?TALARRAY
	MOV	R0,A
	MOV	A,@R0
	MOV	R2,A
	LCALL	?WRITC
	POP	03H
	POP	02H
	INC	?I
	MOV	A,?I
	JZ	$+5
	SJMP	?L8
	NOP
?L9:
 ;end;
	RET
 ;
 ;begin

 ;end.
 EXTRN	CODE ( ?INEG )
 EXTRN	CODE ( ?WDIV )
 EXTRN	CODE ( ?WMOD )
 EXTRN	CODE ( ?ICOMP )
 EXTRN	CODE ( ?WCOMP )
 EXTRN	CODE ( ?WRITC )
LIBEND

LIBRARY	CRLF

PUBLIC	?CRLF
EXTRN	CODE	( ?WRITC )
EXTRN	DATA	( ?DEVICE )

?CRLF?C	SEGMENT	CODE

RSEG 	?CRLF?C

?CRLF:
	MOV	?DEVICE,R3
	MOV	R2,#13
	CALL	?WRITC
	MOV	R2,#10
	CALL	?WRITC
	RET
LIBEND


LIBRARY	IODEFS


 ; ?talarray: array[0..9] of char export;
 PUBLIC ?TALARRAY
?IODEFS?D	SEGMENT	DATA
 RSEG	?IODEFS?D
?TALARRAY:	DS	0AH
 ; ?sign: boolean export;
 PUBLIC ?SIGN
?IODEFS?B	SEGMENT	BIT
 RSEG	?IODEFS?B
?SIGN:	DBIT	01H
 ; ?colonm,?i: byte export;
 PUBLIC ?COLONM
 RSEG	?IODEFS?D
?COLONM:	DS	01H
 PUBLIC ?I
 RSEG	?IODEFS?D
?I:	DS	01H

LIBEND


  LIBRARY	TESTZ
  PUBLIC ?TESTZ
  ?TESTZ?C	SEGMENT	CODE
  RSEG	?TESTZ?C

; The next two routines are not the compiler in release 1.31 and later.

?TESTZ:
	CLR	C
	JNZ	L01
	SETB	C
L01:	RLC	A
	RET

  LIBEND
  LIBRARY	TESTNZ
  PUBLIC ?TESTNZ
  ?TESTNZ?C	SEGMENT	CODE
  RSEG	?TESTNZ?C

?TESTNZ:
	CLR	C
	JZ	L02
	SETB	C
L02:	RLC	A
	RET

;%
  LIBEND
  LIBRARY	IADD
  PUBLIC ?IADD
  ?IADD?C	SEGMENT	CODE
  RSEG	?IADD?C
  
; The routines IADD to IDIV will work on the integer accumulator alt. R2 and R2
; and the 2. operand will be in integer B-reg, R3 and R4.

?IADD:
	MOV	A,R2
	ADD	A,R4
	MOV	R2,A
	MOV	A,R3
	ADDC	A,R5
	MOV	R3,A
	RET

  LIBEND
  LIBRARY	ISUB
  PUBLIC ?ISUB
  ?ISUB?C	SEGMENT	CODE
  RSEG	?ISUB?C

?ISUB:
	MOV	A,R2
	CLR	CY
	SUBB	A,R4
	MOV	R2,A
	MOV	A,R3
	SUBB	A,R5
	MOV	R3,A
	RET

  LIBEND

  LIBRARY	WMUL
  PUBLIC ?WMUL,?IMUL
  ?WMUL?C	SEGMENT	CODE
  RSEG	?WMUL?C

?IMUL:
?WMUL:
	MOV	A,R6
	PUSH	ACC
	MOV	A,R7
	PUSH	ACC
	MOV	A,R2
	MOV	B,R4
	MUL	AB
	MOV	R6,A
	MOV	R7,B
	MOV	A,R2
	MOV	B,R5
	MUL	AB
	ADD	A,R7
	MOV	R7,A
	MOV	A,R3
	MOV	B,R4
	MUL	AB
	ADD	A,R7
	MOV	R3,A
	MOV	A,R6
	MOV	R2,A
	POP	ACC
	MOV	R7,A
	POP	ACC
	MOV	R6,A
	RET

  LIBEND

  LIBRARY	WDIV
  PUBLIC ?WDIV
  EXTRN	CODE	( ?IMD )
  ?WDIV?C	SEGMENT	CODE
  RSEG	?WDIV?C

?WDIV:
	MOV	A,R6
	PUSH	ACC
	MOV	A,R7
	PUSH	ACC
	LCALL	?IMD
	POP	ACC
	MOV	R7,A
	POP	ACC
	MOV	R6,A
	RET

  LIBEND
  
  LIBRARY	IDIV
  PUBLIC ?IDIV
  EXTRN	CODE	( ?IMDBEG,?IMD,?IMDSLT )
  ?IDIV?C	SEGMENT	CODE
  RSEG	?IDIV?C

?IDIV:
	LCALL	?IMDBEG	;calculate sign and make operands positive
	PUSH    PSW
	MOV	A,R6
	PUSH	ACC
	MOV	A,R7
	PUSH	ACC
	LCALL	?IMD
	LJMP	?IMDSLT

  LIBEND
  
  LIBRARY	WMOD
  PUBLIC ?WMOD
  EXTRN	CODE	( ?IMD )
  ?WMOD?C	SEGMENT	CODE
  RSEG	?WMOD?C

?WMOD:	CJNE	R3,#0,WMOD1
	CJNE	R5,#0,WMOD1
	
	MOV	A,R2
	MOV	B,R4
	DIV	AB
	MOV	R2,B
	RET
	
WMOD1:	MOV	A,R6
	PUSH	ACC
	MOV	A,R7
	PUSH	ACC
	LCALL	?IMD
	CLR	C
	MOV	A,R7
	RRC	A
	MOV	R3,A
	MOV	A,R6
	RRC	A
	MOV	R2,A
	POP	ACC
	MOV	R7,A
	POP	ACC
	MOV	R6,A
	RET

LIBEND

  LIBRARY	IMOD
  PUBLIC ?IMOD
  EXTRN	CODE	( ?IMDBEG,?IMD,?IMDSLT,?INEG )
  ?IMOD?C	SEGMENT	CODE
  RSEG	?IMOD?C

?IMOD:	LCALL	?IMDBEG
	PUSH    PSW

	CJNE	R3,#0,IMOD1
	CJNE	R5,#0,IMOD1
	
	MOV	A,R2
	MOV	B,R4
	DIV	AB
	MOV	R2,B
	POP	PSW
	JNC	IMOD2
	CALL	?INEG
IMOD2:	RET

IMOD1:	MOV	A,R6
	PUSH	ACC
	MOV	A,R7
	PUSH	ACC
	LCALL	?IMD
	CLR	C
	MOV	A,R7
	RRC	A
	MOV	R3,A
	MOV	A,R6
	RRC	A
	MOV	R2,A
	LJMP	?IMDSLT

LIBEND

  LIBRARY	IMD
PUBLIC ?IMD
?IMD?C	SEGMENT	CODE
RSEG	?IMD?C

; same routine for integer MOD and DIV.

?IMD:	CJNE	R3,#0,IMDL
	CJNE	R5,#0,IMDL

; 8 bit hardware division possible
	MOV	A,R2
	MOV	B,R4
	DIV	AB
	MOV	R2,A
	MOV	R6,B
	MOV	R7,#0
	RET
	
IMDL:	MOV	A,R0
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	B,#17
	MOV	R6,#0
	MOV	R7,#0
IMD1:	MOV	A,R6
	MOV	R0,A
	MOV	A,R7
	MOV	R1,A
	CLR	CY
	MOV	A,R6
	SUBB	A,R4
	MOV	R6,A
	MOV	A,R7
	SUBB	A,R5
	MOV	R7,A
	CPL	C
	JC	IMD2
	MOV	A,R0
	MOV	R6,A
	MOV	A,R1
	MOV	R7,A
IMD2:	MOV	A,R2
	RLC	A
	MOV	R2,A
	MOV	A,R3
	RLC	A
	MOV	R3,A
	MOV	A,R6
	RLC	A
	MOV	R6,A
	MOV	A,R7
	RLC	A
	MOV	R7,A
	DEC	B
	MOV	A,B
	JNZ	IMD1
	POP	ACC
	MOV	R1,A
	POP	ACC
	MOV	R0,A
	RET

LIBEND

LIBRARY	IMDBEG
PUBLIC ?IMDBEG
?IMDBEG?C	SEGMENT	CODE
RSEG	?IMDBEG?C

?IMDBEG:
	CLR	CY
	MOV	A,R3
	JNB	0E7H,IMD3
	CPL	C
	CPL	A
	MOV	R3,A
	MOV	A,R2
	CPL	A
	INC	A
	MOV	R2,A
	JNZ	IMD3
	INC	R3
IMD3:	MOV	A,R5
	JNB	0E7H,IMD4
	CPL	C
	CPL	A
	MOV	R5,A
	MOV	A,R4
	CPL	A
	INC	A
	MOV	R4,A
	JNZ	IMD4
	INC	R5
IMD4:	RET

LIBEND

LIBRARY	IMDSLT
PUBLIC	?IMDSLT
?IMDSLT?C	SEGMENT	CODE
RSEG	?IMDSLT?C

?IMDSLT:
	POP	ACC
	MOV	R7,A
	POP	ACC
	MOV	R6,A
	POP     PSW
        JNC	IMD5
	MOV	A,R3
	CPL	A
	MOV	R3,A
	MOV	A,R2
	CPL	A
	INC	A
	MOV	R2,A
	JNZ	IMD5
	INC	R3
IMD5:
        RET

LIBEND

  LIBRARY	INEG
  PUBLIC ?INEG
  ?INEG?C	SEGMENT	CODE
  RSEG	?INEG?C

?INEG:
	MOV	A,R3
	CPL	A
	MOV	R3,A
	MOV	A,R2
	CPL	A
	INC	A
	MOV	R2,A
	JNZ	INEG1
	INC	R3
INEG1:
	RET

  LIBEND
LIBRARY ISHL
PUBLIC ?ISHL
?ISHL?C	SEGMENT	CODE
RSEG	?ISHL?C

?ISHL:	MOV	A,R4
	JZ	ISHL2
ISHL1:	CLR	C
	MOV	A,R2
	RLC	A
	MOV	R2,A
	MOV	A,R3
	RLC	A
	MOV	R3,A
	DJNZ	R4,ISHL1
ISHL2:	RET

LIBEND


LIBRARY ISHR
PUBLIC ?ISHR
?ISHR?C	SEGMENT	CODE
RSEG	?ISHR?C

?ISHR:	MOV	A,R4
	JZ	ISHR2
ISHR1:	CLR	C
	MOV	A,R3
	RRC	A
	MOV	R3,A
	MOV	A,R2
	RRC	A
	MOV	R2,A
	DJNZ	R4,ISHR1
ISHR2:	RET

LIBEND



LIBRARY IABS
PUBLIC ?IABS
?IABS?C	SEGMENT	CODE
RSEG	?IABS?C


?IABS:
	MOV	A,R3
	JNB	ACC.7,IABS1	; Negative?
	; Yes, complement
	MOV	A,R2
	CPL	A
	ADD	A,#1
	MOV	R2,A
	MOV	A,R3
	CPL	A
	ADDC	A,#0
	MOV	R3,A
	
IABS1:
	RET

LIBEND



LIBRARY	SETCONV
PUBLIC ?SETCONV
?SETCONV?C	SEGMENT	CODE
RSEG	?SETCONV?C

; Convert a number in ACC to its corresponding SET (in ACC)

?SETCONV:
	INC	A
	MOV	B,A
	CLR	A
	SETB	C
QS1:	RLC	A
	DJNZ	B,QS1
	RET


LIBEND


LIBRARY	CSETINTEST
PUBLIC ?CSETINTEST
?CSETINTEST?C	SEGMENT	CODE
RSEG	?CSETINTEST?C

; Test a number in acc for constant set inclusion; set in code memory.

?CSETINTEST:
	MOV	B,#8
	DIV	AB	; Quotient in A, remainder in B
	POP	DPH
	POP	DPL
	MOVC	A,@A+DPTR	; find appropriate byte
	INC	B
QS1:	RRC	A
	DJNZ	B,QS1	; Shift bit into Cy
	MOV	F0,C
	MOV	A,DPL
	ADD	A,#32	; ajust return address
	PUSH	ACC
	MOV	A,DPH
	ADDC	A,#0
	PUSH	ACC
	MOV	C,F0
	RET


LIBEND

LIBRARY	MASSI0
PUBLIC	?MASSI0
?MASSI0?C	SEGMENT	CODE
RSEG	?MASSI0?C

; Multiple assign routines for various combinations of memories.

; Both in INT RAM.
?MASSI0:
QMA0:	MOV	A,@R0
	MOV	@R1,A
	INC	R0
	INC	R1
	DJNZ	R7,QMA0
	RET

LIBEND

LIBRARY	MASSI1

PUBLIC ?MASSI1

?MASSI1?C	SEGMENT	CODE
RSEG	?MASSI1?C



; Source in INT, dest in EXT ram
?MASSI1:
QMA1:	MOV	A,@R0
	MOVX	@DPTR,A
	INC	R0
	INC	DPTR
	DJNZ	R7,QMA1
	RET

LIBEND

LIBRARY MASSI2

PUBLIC ?MASSI2

?MASSI2?C	SEGMENT	CODE
RSEG	?MASSI2?C


?MASSI2:
QMA2:	MOVX	A,@DPTR
	MOV	@R1,A
	INC	R1
	INC	DPTR
	DJNZ	R7,QMA2
	RET

LIBEND


LIBRARY	MASSI3
PUBLIC ?MASSI3
?MASSI3?C	SEGMENT	CODE
RSEG	?MASSI3?C


; Both in EXT RAM; changed for release 1.31 for full 64K size.
; changed 891130 to work when R7=0, i.e xx00 bytes to be moved

?MASSI3:
	MOV	A,R7
	JZ	QMA3
	INC	R6
QMA3:	MOVX	A,@DPTR
	INC	DPTR
	MOV	R2,DPL
	MOV	R3,DPH
	MOV	DPL,R4
	MOV	DPH,R5
	MOVX	@DPTR,A
	INC	DPTR
	MOV	R4,DPL
	MOV	R5,DPH
	MOV	DPL,R2
	MOV	DPH,R3
	DJNZ	R7,QMA3
	DJNZ	R6,QMA3
	RET

LIBEND

LIBRARY	MASSI4

PUBLIC ?MASSI4
?MASSI4?C	SEGMENT	CODE
RSEG	?MASSI4?C


?MASSI4:
QMA4:	MOV	A,#0
	MOVC	A,@A+DPTR
	MOV	@R1,A
	INC	R1
	INC	DPTR
	DJNZ	R7,QMA4
	RET

LIBEND

LIBRARY	MASSI5
PUBLIC	?MASSI5
?MASSI5?C	SEGMENT	CODE
RSEG	?MASSI5?C


?MASSI5:
	MOV	A,R7
	JZ	QMA5
	INC	R6
QMA5:	MOV	A,#0
	MOVC	A,@A+DPTR
	INC	DPTR
	MOV	R2,DPL
	MOV	R3,DPH
	MOV	DPL,R4
	MOV	DPH,R5
	MOVX	@DPTR,A
	INC	DPTR
	MOV	R4,DPL
	MOV	R5,DPH
	MOV	DPL,R2
	MOV	DPH,R3
	DJNZ	R7,QMA5
	DJNZ	R6,QMA5
	RET

LIBEND

LIBRARY	MCOMP0
PUBLIC	?MCOMP0
?MCOMP0?C	SEGMENT	CODE
RSEG	?MCOMP0?C

; 6 routines for comparing arrays.

?MCOMP0:
QMC0:	CLR	C
	MOV	A,@R0
	SUBB	A,@R1
	INC	R0
	INC	R1
	JNZ	QMC01
	DJNZ	R7,QMC0
	CLR	C
	RET
QMC01:	SETB	C
	RET

LIBEND

LIBRARY	MCOMP1
PUBLIC	?MCOMP1
?MCOMP1?C	SEGMENT	CODE
RSEG	?MCOMP1?C


?MCOMP1:
QMC1:	CLR	C
	MOVX	A,@DPTR
	SUBB	A,@R0
	INC	R0
	INC	DPTR
	JNZ	QMC11
	DJNZ	R7,QMC1
	CLR	C
	RET
QMC11:	SETB	C
	RET

LIBEND

LIBRARY	MCOMP2
PUBLIC	?MCOMP2
?MCOMP2?C	SEGMENT	CODE
RSEG	?MCOMP2?C


?MCOMP2:
QMC2:	CLR	C
	MOVX	A,@DPTR
	SUBB	A,@R1
	INC	R1
	INC	DPTR
	JNZ	QMC21
	DJNZ	R7,QMC2
	CLR	C
	RET
QMC21:	SETB	C
	RET

LIBEND

LIBRARY	MCOPM3
PUBLIC ?MCOMP3
?MCOMP3?C	SEGMENT	CODE
RSEG	?MCOMP3?C


?MCOMP3:
QMC3:	CLR	C
	MOVX	A,@DPTR
	MOV	R6,A
	INC	DPTR
	MOV	R2,DPL
	MOV	R3,DPH
	MOV	DPL,R4
	MOV	DPH,R5
	MOVX	A,@DPTR
	SUBB	A,R6
	JNZ	QMC31
	INC	DPTR
	MOV	R4,DPL
	MOV	R5,DPH
	MOV	DPL,R2
	MOV	DPH,R3
	DJNZ	R7,QMC3
	CLR	C
	RET
QMC31:	SETB	C
	RET

LIBEND

LIBRARY	MCOMP4
PUBLIC ?MCOMP4
?MCOMP4?C	SEGMENT	CODE
RSEG	?MCOMP4?C


?MCOMP4:
QMC4:	CLR	C
	MOV	A,#0
	MOVC	A,@A+DPTR
	SUBB	A,@R1
	JNZ	QMC41
	INC	R1
	INC	DPTR
	DJNZ	R7,QMC4
	CLR	C
	RET
QMC41:	SETB	C
	RET

LIBEND

LIBRARY	MCOMP5
PUBLIC	?MCOMP5
?MCOMP5?C	SEGMENT	CODE
RSEG	?MCOMP5?C



?MCOMP5:
QMC5:	CLR	C
	MOV	A,#0
	MOVC	A,@A+DPTR
	MOV	R6,A
	INC	DPTR
	MOV	R2,DPL
	MOV	R3,DPH
	MOV	DPL,R4
	MOV	DPH,R5
	MOVX	A,@DPTR
	MOV	DPL,R2
	MOV	DPH,R3
	SUBB	A,R6
	JNZ	QMC51
	INC	DPTR
	MOV	R4,DPL
	MOV	R5,DPH
	DJNZ	R7,QMC5
	CLR	C
	RET
QMC51:	SETB	C
	RET

LIBEND


LIBRARY	DCOMP0

; 6 routines for comparing text strings.

PUBLIC	?DCOMP0
?DCOMP0?C	SEGMENT	CODE
RSEG	?DCOMP0?C

?DCOMP0:
	MOV	A,@R0
	MOV	R2,A
	MOV	A,@R1
	MOV	R3,A
	
QDC0:	INC	R0
	INC	R1
	MOV	A,R2
	JZ	QDC1
	MOV	A,R3
	JZ	QDC2
	DEC	R2
	DEC	R3
	CLR	C
	MOV	A,@R0
	SUBB	A,@R1
	JZ	QDC0

QDC01:
	RET

QDC1:	MOV	A,R3
	JZ	QDC01
	SETB	C
	RET

QDC2:	MOV	A,R2
	CLR	C
	RET
	
	

LIBEND

LIBRARY	DCOMP1
PUBLIC	?DCOMP1
?DCOMP1?C	SEGMENT	CODE
RSEG	?DCOMP1?C

?DCOMP1:
	MOV	A,@R0
	MOV	R2,A
	MOVX	A,@DPTR
	MOV	R3,A
QDC1:	MOV	A,R2
	JZ	QDC12
	MOV	A,R3
	JZ	QDC13
	INC	R0
	INC	DPTR
	DEC	R2
	DEC	R3
	CLR	C
	MOVX	A,@DPTR
	SUBB	A,@R0
	JZ	QDC1

QDC11:
	RET

QDC12:	MOV	A,R3
	JZ	QDC11
	SETB	C
	RET

QDC13:	MOV	A,R2
	CLR	C
	RET

LIBEND
  
  
LIBRARY	DCOMP2
PUBLIC	?DCOMP2
?DCOMP2?C	SEGMENT	CODE
RSEG	?DCOMP2?C

?DCOMP2:
	MOVX	A,@DPTR
	MOV	R2,A
	MOV	A,@R1
	MOV	R3,A
QDC2:	MOV	A,R2
	JZ	QDC22
	MOV	A,R3
	JZ	QDC23
	DEC	R2
	DEC	R3
	CLR	C
	MOVX	A,@DPTR
	SUBB	A,@R1
	INC	R1
	INC	DPTR
	JZ	QDC2
QDC21:
	RET

QDC22:	MOV	A,R3
	JZ	QDC21
	SETB	C
	RET

QDC23:	MOV	A,R2
	RET


LIBEND


LIBRARY	DCOMP3
PUBLIC	?DCOMP3
?DCOMP3?C	SEGMENT	CODE
RSEG	?DCOMP3?C

?DCOMP3:
	MOV	R2,DPL
	MOV	R3,DPH
	MOVX	A,@DPTR
	MOV	R0,A
	MOV	DPL,R4
	MOV	DPH,R5
	MOVX	A,@DPTR
	MOV	R1,A
QDC3:	MOV	A,R0
	JZ	QDC32
	MOV	A,R1
	JZ	QDC33
	CLR	C
	MOV	DPL,R2
	MOV	DPH,R3
	INC	DPTR
	MOVX	A,@DPTR
	MOV	R6,A
	MOV	R2,DPL
	MOV	R3,DPH
	MOV	DPL,R4
	MOV	DPH,R5
	INC	DPTR
	MOVX	A,@DPTR
	MOV	R4,DPL
	MOV	R5,DPH
	DEC	R0
	DEC	R1
	SUBB	A,R6
	JZ	QDC3

QDC31:
	RET

QDC32:	MOV	A,R1
	JZ	QDC31
	SETB	C
	RET

QDC33:	MOV	A,R0
	RET
	

LIBEND


LIBRARY	DCOMP4
PUBLIC	?DCOMP4
?DCOMP4?C	SEGMENT	CODE
RSEG	?DCOMP4?C


?DCOMP4:
	MOV	A,#0
	MOVC	A,@A+DPTR
	MOV	R2,A
	MOV	A,@R1
	MOV	R3,A
QDC4:	MOV	A,R3
	JZ	QDC42
	MOV	A,R3
	JZ	QDC43
	DEC	R2
	DEC	R3
	CLR	C
	MOV	A,#0
	MOVC	A,@A+DPTR
	SUBB	A,@R1
	INC	R1
	INC	DPTR
	JZ	QDC4
QDC41:
	RET

QDC42:	MOV	A,R3
	JZ	QDC41
	SETB	C
	RET

QDC43:	MOV	A,R2
	RET


LIBEND


LIBRARY	DCOMP5
PUBLIC	?DCOMP5
?DCOMP5?C	SEGMENT	CODE
RSEG	?DCOMP5?C


?DCOMP5:
	MOV	R2,DPL
	MOV	R3,DPH
	MOV	A,#0
	MOVC	A,@A+DPTR
	MOV	R0,A
	MOV	DPL,R4
	MOV	DPH,R5
	MOVX	A,@DPTR
	MOV	R1,A

QDC5:	MOV	A,R0
	JZ	QDC52
	MOV	A,R1
	JZ	QDC53
	DEC	R0
	DEC	R1
	CLR	C
	MOV	DPL,R2
	MOV	DPH,R3
	MOV	A,#0
	INC	DPTR
	MOVC	A,@A+DPTR
	MOV	R6,A
	MOV	R2,DPL
	MOV	R3,DPH
	MOV	DPL,R4
	MOV	DPH,R5
	INC	DPTR
	MOVX	A,@DPTR
	MOV	R4,DPL
	MOV	R5,DPH
	SUBB	A,R6
	JZ	QDC5

QDC51:
	RET

QDC52:	MOV	A,R1
	JZ	QDC51
	SETB	C
	RET

QDC53:	MOV	A,R0
	RET

LIBEND


LIBRARY	NEW

; HEAP management routines: NEW, RELEASE and MARK

PUBLIC ?NEW
EXTRN   DATA    ( ?HEAPPTR )
?NEW?C	SEGMENT	CODE
RSEG	?NEW?C

?NEW:
	MOV	A,?HEAPPTR
	MOVX	@DPTR,A
	ADD	A,R7
	MOV	?HEAPPTR,A
	INC	DPTR
	MOV	A,?HEAPPTR+1
	MOVX	@DPTR,A
	ADDC	A,#0
	MOV	?HEAPPTR+1,A
	RET

LIBEND

LIBRARY	RELEASE
PUBLIC	?RELEASE
EXTRN   DATA    ( ?HEAPPTR )
?RELEASE?C	SEGMENT	CODE
RSEG	?RELEASE?C

?RELEASE:
	MOVX	A,@DPTR
	MOV	?HEAPPTR,A
	INC	DPTR
	MOVX	A,@DPTR
	MOV	?HEAPPTR+1,A
	RET

LIBEND

LIBRARY	MARK
PUBLIC	?MARK
EXTRN   DATA    ( ?HEAPPTR )
?MARK?C	SEGMENT	CODE
RSEG	?MARK?C

?MARK:	MOV	A,?HEAPPTR
	MOVX	@DPTR,A
	INC	DPTR
	MOV	A,?HEAPPTR+1
	MOVX	@DPTR,A
	RET

LIBEND

LIBRARY	INDEXC
PUBLIC	?INDEXC
?INDEXC?C	SEGMENT	CODE
RSEG	?INDEXC?C
  
; Calculate array index for small arrays.


?INDEXC:
	MUL	AB
	ADD	A,DPL
	MOV	DPL,A
	MOV	A,DPH
	ADDC	A,#0
	MOV	DPH,A
	MOV	A,DPL
	ADD	A,R7
	MOV	DPL,A
	MOV	A,DPH
	ADDC	A,#0
	MOV	DPH,A
	RET


LIBEND

LIBRARY	INDEXI
PUBLIC	?INDEXI
?INDEXI?C	SEGMENT	CODE
RSEG	?INDEXI?C

; Calculate array index for big arrays.
	
?INDEXI:
	MOV	A,R4
	CLR	C
	SUBB	A,R6
	MOV	R4,A
	MOV	A,R5
	SUBB	A,R7
	MOV	R5,A
	PUSH	B
	MOV	A,R4
	MUL	AB
	ADD	A,DPL
	MOV	DPL,A
	MOV	A,B
	ADDC	A,DPH
	MOV	DPH,A
	POP	B
	MOV	A,R5
	MUL	AB
	ADD	A,DPH
	MOV	DPH,A
	RET
LIBEND

LIBRARY	INDEXIA
PUBLIC	?INDEXIA
?INDEXIA?C	SEGMENT	CODE
RSEG	?INDEXIA?C

; Calculate array index for large arrays of large arrays.
	
?INDEXIA:
	MOV	A,R2
	CLR	C
	SUBB	A,R6	; subtract offset
	MOV	R2,A
	MOV	A,R3
	SUBB	A,R7
	MOV	R3,A
	MOV	B,R0
	MOV	A,R2
	MUL	AB	; lo(index)*lo(rep) (16 bit result)
	ADD	A,DPL
	MOV	DPL,A
	MOV	A,B
	ADDC	A,DPH
	MOV	DPH,A
	MOV	B,R0
	MOV	A,R3
	MUL	AB	; hi(index)*lo(rep) (8 bit shl 8 result)
	ADD	A,DPH
	MOV	DPH,A
	MOV	A,R2
	MOV	B,R1
	MUL	AB	; lo(index)*hi(rep) (8 bit shl 8 result)
	ADD	A,DPH
	MOV	DPH,A
	RET
LIBEND


LIBRARY	WCOMP
  
; WCOMP compares 2 words in integer accumulator and integer B.
PUBLIC  ?WCOMP
?WCOMP?C	SEGMENT	CODE
RSEG	?WCOMP?C

?WCOMP:	
	MOV	A,R3
	CLR	C
	SUBB	A,R5
	JZ	WCOMP1
	RET
WCOMP1:	MOV	A,R2
	CLR	C
	SUBB	A,R4
	RET

LIBEND
  
LIBRARY	ICOMP
  
; ICOMP compares 2 integers in integer accumulator and integer B.
PUBLIC  ?ICOMP
?ICOMP?C	SEGMENT	CODE
RSEG	?ICOMP?C

?ICOMP:	
	MOV	A,R5
	MOV	B,A
	XRL	A,#80H
	MOV	R5,A
	MOV	A,R3
	XRL	A,#80H
	CLR	C
	SUBB	A,R5
	JZ	ICOMP1
	MOV	R5,B
	RET
ICOMP1:	MOV	A,R2
	CLR	C
	SUBB	A,R4
	MOV	R5,B
	RET

LIBEND
  



LIBRARY	TRANSFER
PUBLIC	?TRANSFER,?NEWPROCESS
?TRANSFER?C	SEGMENT	CODE
RSEG	?TRANSFER?C
  
  ; routine for transfer of process in multi process systems.

  EXTRN DATA ( ?STACKPTR )
  EA BIT 0AFH

  ?TRANSFER:
          MOV R1,6
          MOV @R1,SP
          INC R1
          MOV R0,?STACKPTR
          MOV R7,#5
  TRF1:   MOV A,@R0
          MOV @R1,A
          INC R0
          INC R1
          DJNZ R7,TRF1
          MOV R0,?STACKPTR
          MOV R1,5
          MOV R7,#5
          JNB EA,TRF4
          CLR EA
          MOV SP,@R1
          INC R1
  TRF2:   MOV A,@R1
          MOV @R0,A
          INC R0
          INC R1
          DJNZ R7,TRF2
          SETB EA
          RET

  TRF4:   MOV SP,@R1
          INC R1
  TRF3:   MOV A,@R1
          MOV @R0,A
          INC R0
          INC R1
          DJNZ R7,TRF3
          RET

?NEWPROCESS:
				; R0, bank 0 points to process descriptor
	MOV	@R0,?STACKPTR	
	INC	@R0             ; let comming stackpointer point to start address
	INC	R0
	MOV	@R0,DPL		; put start address in process descriptor
	INC	R0
	MOV	@R0,DPH
	RET


LIBEND

LIBRARY USE0INT

PUBLIC	?ENTERUSE0, ?LEAVUSE0

EXTRN	DATA	( ?FLOATBUFFER )

EXTRN	BIT	( ?SIGNX,?SIGNY )

?USE0INT?C	SEGMENT	CODE

RSEG	?USE0INT?C

ENT1:	MOV	A,@R0
	INC	R0
	MOVX	@DPTR,A
	INC	DPTR
	DJNZ	R1,ENT1
	RET
	
?ENTERUSE0:

	MOV	A,R0
	MOVX	@DPTR,A
	INC	DPTR
	
	MOV	A,R1
	MOVX	@DPTR,A
	INC	DPTR
	
	MOV	R0,#2
	MOV	R1,#6
	CALL	ENT1
	
	MOV	R0,#?FLOATBUFFER 
	MOV	R1,#20
	CALL	ENT1
	
	MOV	C,?SIGNX
	RLC	A
	MOV	C,?SIGNY
	RLC	A
	MOVX	@DPTR,A

	RET

LEAV1:	MOVX	A,@DPTR
	INC	DPTR
	MOV	@R0,A
	INC	R0
	DJNZ	R1,LEAV1
	RET
	
?LEAVUSE0:


	MOVX	A,@DPTR
	PUSH	ACC
	INC	DPTR
	
	MOVX	A,@DPTR
	PUSH	ACC
	INC	DPTR
	
	MOV	R0,#2
	MOV	R1,#6
	CALL	LEAV1
	
	MOV	R0,#?FLOATBUFFER 
	MOV	R1,#20
	CALL	LEAV1
	
	MOVX	A,@DPTR
	RRC	A
	MOV	?SIGNY,C
	RRC	A
	MOV	?SIGNX,C
	
	POP	1
	POP	0

	RET

LIBEND

LIBRARY EXECPROC

PUBLIC	?EXECPROC

?EXECPROC?C	SEGMENT	CODE

RSEG	?EXECPROC?C

?EXECPROC:

	MOV	DPL,R2
	MOV	DPH,R3
	MOV	A,#0
	JMP	@A+DPTR

LIBEND

LIBRARY FLOATBUFFER

PUBLIC ?FLOATBUFFER,?X,?Y,?Z,?SIGNX,?SIGNY
PUBLIC	?USERDPL,?USERDPH,?SYSDPL,?SYSDPH,?USERCOUNT,?SYSCOUNT

?FLOATBUF?D	SEGMENT	DATA
?FLOATBUF?B	SEGMENT	BIT

	RSEG	?FLOATBUF?D
?FLOATBUFFER:	DS	5
?Z:		DS	5
?Y:		DS	5
?X:		DS	5


?USERDPL	EQU	?FLOATBUFFER
?USERDPH	EQU	?FLOATBUFFER+1
?SYSDPL		EQU	?FLOATBUFFER+2
?SYSDPH		EQU	?FLOATBUFFER+3
?USERCOUNT	EQU	?FLOATBUFFER+4
?SYSCOUNT	EQU	?FLOATBUFFER+5

RSEG	?FLOATBUF?B

?SIGNX:	DBIT	1
?SIGNY:	DBIT	1

LIBEND

LIBRARY	?RRECUR

?RRECUR?C	SEGMENT	CODE
?RRECUR?D	SEGMENT	DATA

PUBLIC	?RENTERCALC,?RENTERPROC,?RLEAVPROC,?RLOCAL0,?RLOCAL1,?RINITRECUR

RSEG	?RRECUR?D

?FRAMEPTR:	DS	1


RSEG	?RRECUR?C

?RINITRECUR:
	
	MOV	?FRAMEPTR,SP
	
	DEC	?FRAMEPTR
	
	RET
		
?RENTERCALC:

	POP	DPH
	POP	DPL
	
	ADD	A,SP
	MOV	SP,A
	
	MOV	A,#0
	JMP	@A+DPTR

?RENTERPROC:
	POP	DPH
	POP	DPL
	
	PUSH	?FRAMEPTR
	MOV	?FRAMEPTR,SP
	INC	?FRAMEPTR
	
	ADD	A,SP
	MOV	SP,A
	
	
	MOV	A,#0
	JMP	@A+DPTR

?RLEAVPROC:

	MOV	SP,?FRAMEPTR
	DEC	SP
	POP	?FRAMEPTR
		
	POP	DPH
	POP	DPL
	
	ADD	A,SP
	MOV	SP,A
	
	MOV	A,#0
	JMP	@A+DPTR


?RLOCAL0:
	PUSH	ACC
	MOV	A,?FRAMEPTR
	ADD	A,R0
	MOV	R0,A
	
	POP	ACC
	RET

?RLOCAL1:
	PUSH	ACC
	MOV	A,?FRAMEPTR
	ADD	A,R1
	MOV	R1,A
	
	POP	ACC
	RET


LIBEND

LIBRARY	?XRECUR

?XRECUR?C	SEGMENT	CODE
?XRECUR?X	SEGMENT XDATA
?XRECUR?D	SEGMENT	DATA

PUBLIC	?ENTERPROC,?LEAVPROC,?XLOCAL,?INITRECUR

RSEG	?XRECUR?D

?FRAMEPTR:	DS	2

RSEG	?XRECUR?X

XSTART:

RSEG	?XRECUR?C

?INITRECUR:
	MOV	DPTR,#XSTART
	MOV	?FRAMEPTR,DPL
	MOV	?FRAMEPTR+1,DPH
	RET
	
?ENTERPROC:
	POP	2
	POP	3
	
	PUSH	?FRAMEPTR
	PUSH	?FRAMEPTR+1
	
	MOV	A,?FRAMEPTR
	ADD	A,DPL
	MOV	?FRAMEPTR,A
	
	MOV	A,?FRAMEPTR+1
	ADDC	A,DPH
	MOV	?FRAMEPTR+1,A
	
	PUSH	3
	PUSH	2
	
	RET

?LEAVPROC:
	POP	2
	POP	3
	
	POP	?FRAMEPTR+1
	POP	?FRAMEPTR
	
	PUSH	3
	PUSH	2
	
	RET


?XLOCAL:
	PUSH	ACC
	MOV	A,?FRAMEPTR
	ADD	A,DPL
	MOV	DPL,A
	
	MOV	A,?FRAMEPTR+1
	ADDC	A,DPH
	MOV	DPH,A
	
	POP	ACC
	RET


LIBEND

LIBRARY	HEAP
PUBLIC	?INITHEAP,?HEAPPTR
?HEAP?X	SEGMENT	XDATA
?HEAP?C	SEGMENT	CODE
?HEAP?D	SEGMENT	DATA
RSEG	?HEAP?X

?HEAP:	DS	1	; Heap: rest of xdata memory

RSEG	?HEAP?D

?HEAPPTR:
	DS	2

RSEG	?HEAP?C

?INITHEAP:
	MOV	DPTR,#?HEAP
	MOV	?HEAPPTR,DPL
	MOV	?HEAPPTR+1,DPH
	RET

LIBEND

END
